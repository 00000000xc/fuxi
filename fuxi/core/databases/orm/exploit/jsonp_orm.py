#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author  : jeffzhang
# @Time    : 2019/7/9
# @File    : jsonp.py
# @Desc    : ""

import os
import time
from bson import ObjectId
from fuxi.common.utils.random_str import random_str
from fuxi.core.databases.db_error import DatabaseError
from fuxi.core.databases.db_mongo import mongo, T_JSON_HIJACKER_TASK, T_JSON_HIJACKER_RES
from fuxi.common.utils.logger import logger


def _get_template():
    file_path = os.path.abspath(os.path.dirname(__file__))
    with open(file_path + '/jsonp_hijacking_template.html', 'r', encoding="UTF-8") as f_read:
        return f_read.read()


class _DBExploitJsonpTask:
    def __init__(self):
        self.table = T_JSON_HIJACKER_TASK

    def find_one(self):
        return mongo[self.table].find_one()

    def get_detail_by_id(self, _id):
        return mongo[self.table].find_one({"_id": ObjectId(str(_id))})

    def get_detail_by_short_id(self, short_id):
        return mongo[self.table].find_one({"short_id": short_id})

    def get_list(self, query=None, data_filter=None):
        return mongo[self.table].find(query, data_filter).sort("date", -1).limit(1000)

    def add(self, name, url, op):
        if name and url:
            target = url.split('?')[0]
            short_id = random_str(5)
            target_url = url + "?callback=?" if len(url.split("?")) == 1 else url + "&callback=?"
            html = _get_template() % {"target_url": target_url}
            inserted_id = mongo[self.table].insert_one({
                "name": name.strip(), "target": target, "html": html,
                "short_id": short_id, "url": url.strip(), "op": op,
                "date": int(time.time())
            }).inserted_id
            return str(inserted_id)
        else:
            logger.error("jsonp hijacking task insert failed: invalid data")
            raise DatabaseError("invalid data")

    def delete_by_id(self, _id):
        return mongo[self.table].delete_one({"_id": ObjectId(str(_id))})

    def filter_by_keyword(self, keyword):
        keyword = keyword.lower()
        return mongo[self.table].find({
            "$or": [
                {"name": {'$regex': keyword}}, {"target": {'$regex': keyword}},
                {"short_id": {'$regex': keyword}}, {"url": {'$regex': keyword}}
            ]
        }).sort("date", -1).limit(1000)

    def get_html(self, short_id):
        item = mongo[self.table].find_one({"short_id": short_id})
        return item['html'] if item else ""


class _DBExploitJsonpRes:
    def __init__(self):
        self.table = T_JSON_HIJACKER_RES

    def find_one(self):
        return mongo[self.table].find_one()

    def get_count_by_tid(self, tid):
        return mongo[self.table].find({"tid": str(tid)}).count()

    def get_detail_by_id(self, _id):
        return mongo[self.table].find_one({"_id": ObjectId(str(_id))})

    def get_list_by_tid(self, tid):
        return mongo[self.table].find({"tid": tid}).sort("date", -1).limit(1000)

    def get_list(self, query=None, data_filter=None):
        return mongo[self.table].find(query, data_filter).sort("date", -1).limit(1000)

    def add(self, tid, data, op, ip='127.0.0.1', referrer='-'):
        if tid and data and op:
            inserted_id = mongo[self.table].insert_one({
                "tid": tid, "data": data, "op": op,
                "ip": ip, "referrer": referrer,
                "date": int(time.time())
            }).inserted_id
            return str(inserted_id)
        else:
            logger.error("jsonp hijacking res insert failed: invalid data")
            raise DatabaseError("invalid data")

    def delete_by_id(self, _id):
        return mongo[self.table].delete_one({"_id": ObjectId(str(_id))})

    def filter_task_res_by_keyword(self, tid, keyword):
        keyword = keyword.lower()
        return mongo[self.table].find({
            "$or": [
                {"ip": {'$regex': keyword}}, {"data": {'$regex': keyword}}
            ],
            "tid": tid
        }).sort("date", -1).limit(1000)


DBExploitJsonpTask = _DBExploitJsonpTask()
DBExploitJsonpRes = _DBExploitJsonpRes()

